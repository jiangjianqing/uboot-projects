跳转到某个地址并不是由bl指令所决定，而是由当前pc值决定。反汇编显示这个值只是为了方便读代码。

重点： 反汇编文件里， B或BL 某个值，只是起到方便查看的作用，并不是真的跳转。 

怎么写位置无关码？

    使用相对跳转命令 b或bl;
    重定位之前，不可使用绝对地址，不可访问全局变量/静态变量，也不可访问有初始值的数组(因为初始值放在rodata里，使用绝对地址来访问)；
    重定位之后，使用ldr pc = xxx，跳转到/runtime地址；

写位置无关码，其实就是不使用绝对地址，判断有没有使用绝对地址，除了前面的几个规则，最根本的办法看反汇编。 


 看下面这个ARM汇编吧
BL  NEXT                                 ；跳转到子程序  LR（R14）保存了返回地址
.........                                          ；NEXT处执行
NEXT:
..........
MOV  PC,LR                            ；从子程序返回,PC（R15）是当前地址，把LR给PC就是从子程序返回

 1.SP（R13） LR（R14）PC（R15）
2.lr(r14）的作用问题，这个lr一般来说有两个作用：
1》.当使用bl或者blx跳转到子过程的时候，r14保存了返回地址，可以在调用过程结尾恢复。
2》.异常中断发生时，这个异常模式特定的物理R14被设置成该异常模式将要返回的地址。
另外注意pc，在调试的时候显示的是当前指令地址，而用mov lr,pc的时候lr保存的是此指令向后数两条指令的地址，大家可以试一下用mov pc,pc，结果得到的是跳转两条指令，这个原因是由于arm的流水线造成的，预取两条指令的结果.

 子程序返回的三种方法
现在总结如下
1.MOV PC，LR
2.BL LR
3.在子程序入口处使用以下指令将R14存入堆栈
STMFD    SP！，{<Regs>,LR}
对应的，使用以下指令可以完成子程序的返回
LDMFD  SP!,      {<Regs>,LR}


    obj-y = xxx.o：是最基本的赋值，make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。
    obj-y := xxx.o：是覆盖之前的值，表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。
    obj-y ？= xxx.o：是如果没有被赋值过就赋予等号后面的值
    obj-y += xxx.o：是添加等号后面的值

 　　在生成built-in.o的时候，如果使用：使 obj 的值为 lowlevel_init.o，覆盖了mini2440.c。
