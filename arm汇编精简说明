#lsl 逻辑移位命令范例,lsl #2 = x4
ldrls   r0, [r3, r1, lsl #2]     <<<< [r3, r1, lsl #2] = r3 + r1 << 2 ,最终 r0 = 【r3 + r1 << 2】 

#cmp  cmn
cmn r4, #2                   <<<cmn 是负值比较,r4 == -2??

MOV  R0, #5             ###先将5存储到R0寄存器上（R0 = 5）, 。
MOV  R1, R0, LSL #2     ###然后将R0逻辑左移2位后传送到R1寄存器中,其实每逻辑左移1位就相当于原数值进行乘2操作，5逻辑左移2位其实就是5 x 2^2 = 20

mvn与MOV指令不同之处是在传送之前按位被取反了，即把一个被取反的值传送到目的寄存器中。
4(00000100b) 取反为 11111011,而11111011高位为1,为负数（负数以补码形式表示）,故取反加1，结果为5,加上符号就为-5 

范例1：
mvn r0,#4    
0000 0100   # #4的二进制值 
1111 1011   # 4取反后的值 ,即r0中的值,用无符号整数表示就是0xfffffffd,在有符号整数中符号为1 即 负数,那么有符号整数等于多少？？

计算有符号整数值：0xfffffffd为负数（负数以补码形式表示）,故取反加1
0000 0100   #先对0xfffffffd取反
0000 0101   #加1 , 结果为5 ，但是还要带上0xfffffffd的符号位，因此最终结果=-5

范例2：
mvn r0,#18
0001 0010   # #18二进制的值
1110 1101   # #18取反后的值 32位无符号整数值 = 0xffffffed，在有符号整数中符号为1 即 负数

计算有符号整数值:
0001 0010   # 对 0xffffffed 取反
0001 0011   # 加1 , 结果为19,但是还要带上符号位,即-19

注意：arm汇编中的立即数智能用无符号数表示！！！！
c语言负数赋值语句转arm汇编的范例：
#define ENODEV 19 
int a = -ENODEV     #a=-19    
求等价arm汇编语句生成：
mvn r0,#??
0001 0011   #先求出整数19的二进制值，
0001 0010   #由于-19是负数，所以要-1 ,结果=18,32位无符号整数表示为0xFFFFFFED ,最低字节2进制值 = 1110 1101
mvn r0 , #18    

1字节内的负的有符号数转正的无符号数简单计算法： 先去负号再减1
步骤1: -19取绝对值 = 19       #即去掉符号位
步骤2: 19 -1 = 18           #因为-19是负数，所以要-1
结果 = 18
---------------------------------------------------------


跳转到某个地址并不是由bl指令所决定，而是由当前pc值决定。反汇编显示这个值只是为了方便读代码。

重点： 反汇编文件里， B或BL 某个值，只是起到方便查看的作用，并不是真的跳转。 

怎么写位置无关码？

    使用相对跳转命令 b或bl;
    重定位之前，不可使用绝对地址，不可访问全局变量/静态变量，也不可访问有初始值的数组(因为初始值放在rodata里，使用绝对地址来访问)；
    重定位之后，使用ldr pc = xxx，跳转到/runtime地址；

写位置无关码，其实就是不使用绝对地址，判断有没有使用绝对地址，除了前面的几个规则，最根本的办法看反汇编。 


 看下面这个ARM汇编吧
BL  NEXT                                 ；跳转到子程序  LR（R14）保存了返回地址
.........                                          ；NEXT处执行
NEXT:
..........
MOV  PC,LR                            ；从子程序返回,PC（R15）是当前地址，把LR给PC就是从子程序返回

 1.SP（R13） LR（R14）PC（R15）
2.lr(r14）的作用问题，这个lr一般来说有两个作用：
1》.当使用bl或者blx跳转到子过程的时候，r14保存了返回地址，可以在调用过程结尾恢复。
2》.异常中断发生时，这个异常模式特定的物理R14被设置成该异常模式将要返回的地址。
另外注意pc，在调试的时候显示的是当前指令地址，而用mov lr,pc的时候lr保存的是此指令向后数两条指令的地址，大家可以试一下用mov pc,pc，结果得到的是跳转两条指令，这个原因是由于arm的流水线造成的，预取两条指令的结果.

 子程序返回的三种方法
现在总结如下
1.MOV PC，LR
2.BL LR
3.在子程序入口处使用以下指令将R14存入堆栈
STMFD    SP！，{<Regs>,LR}
对应的，使用以下指令可以完成子程序的返回
LDMFD  SP!,      {<Regs>,LR}


    obj-y = xxx.o：是最基本的赋值，make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。
    obj-y := xxx.o：是覆盖之前的值，表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。
    obj-y ？= xxx.o：是如果没有被赋值过就赋予等号后面的值
    obj-y += xxx.o：是添加等号后面的值

 　　在生成built-in.o的时候，如果使用：使 obj 的值为 lowlevel_init.o，覆盖了mini2440.c。
